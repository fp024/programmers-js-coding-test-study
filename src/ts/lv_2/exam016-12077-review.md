# 📝 전화번호 목록 문제 리뷰 (exam016-12077)

## 1. 문제 분석 및 접근
- **핵심**: 한 번호가 다른 번호의 '접두어'인 경우가 있는지 확인.
- **데이터 규모**: 전화번호부 최대 1,000,000개 (효율성 매우 중요).

## 2. 풀이 비교

### ❌ 시도 1: 길이순 정렬 + 이중 루프 (`exam016-12077.ts`)
- **전략**: 짧은 번호순으로 정렬 후, 뒤에 있는 모든 번호와 대조.
- **복잡도**: $O(N^2)$
- **결과**: 효율성 테스트 실패. 데이터가 많을 때 연산량이 너무 많음.

### ✅ 시도 2: 사전순 정렬 + 인접 비교 (`exam016-12077-a.ts`)
- **전략**: 사전순 정렬을 하면 접두어 관계인 번호들이 서로 옆에 붙는 특징을 이용.
- **복잡도**: $O(N \log N)$ (정렬)
- **결과**: 효율성 테스트 통과!

## 3. 새로 배운 점 (Today I Learned)
- **`sort()`의 파괴적 속성**: 원본 배열을 직접 수정하므로, 원본 보존이 필요하면 `[...arr].sort()` 또는 최신 환경의 `toSorted()`를 사용해야 함. (현재 프로젝트 타겟은 ES2022라 스프레드 연산자 사용 중)
- **`Array.prototype.some()`**: 배열 요소 중 하나라도 조건을 만족하면 즉시 실행을 멈추고 `true`를 반환. `for...break` 문을 더 깔끔하게 대체 가능!
- **정렬의 힘**: 단순한 정렬 기준(`길이순` vs `사전순`) 변경만으로도 알고리즘의 시간 복잡도를 획기적으로 줄일 수 있음을 체감함.

---
*학습 날짜: 2026-01-15*


# 리뷰 상세

두 코드의 차이점과 효율성 측면에서 아주 중요한 포인트를 잘 짚으셨네요! 작성하신 `exam016-12077.ts`와 `exam016-12077-a.ts`를 비교 리뷰해 드릴게요.

---

### 1. 첫 번째 코드 (`exam016-12077.ts`) - 길이순 정렬
이 방식은 **완전 탐색**에 가깝습니다.

*   **전략**: 짧은 번호부터 하나씩 잡고(`base`), 그 뒤에 있는 모든 번호(`target`)들과 대조합니다.
*   **문제점 (효율성 실패 원인)**:
    *   **시간 복잡도**: $O(N^2 \times L)$ (N은 전화번호 개수, L은 번호 평균 길이).
    *   전화번호가 100만 개까지 들어올 수 있는 문제라면, 이 중첩 루프는 백만 $\times$ 백만 번의 연산이 필요해서 반드시 시간 초과가 납니다.
    *   `startsWith`는 편리하지만, 결국 루프 안에서 루프가 도는 구조를 피할 수 없습니다.

### 2. 두 번째 코드 (`exam016-12077-a.ts`) - 사전순 정렬 (개선됨)
이 코드가 효율성 테스트를 통과하는 **정석적인 풀이**입니다. 👏

*   **전략**: 문자열을 **사전순(Lexicographical)**으로 정렬하면, 접두어 관계에 있는 번호들이 **무조건 서로 옆에 붙게 됩니다.**
    *   예: `['12', '123', '1235']` 처럼 정렬됨.
*   **장점**:
    *   **시간 복잡도**: $O(N \log N)$ (정렬 시간) + $O(N)$ (한 번의 루프).
    *   내 바로 다음 번호(`i+1`)만 확인하면 되기 때문에 중첩 루프가 사라져 성능이 획기적으로 좋아집니다.

---

### 💡 추가 리팩토링 및 팁

1.  **`Set` 사용에 대하여**:
```typescript
const phoneBookSet = new Set(phone_book);
    const sortedPhoneBook = [...phoneBookSet].sort();
```

    *   문제 조건상 중복된 전화번호는 들어오지 않는다고 되어 있으므로, 사실 `new Set()`을 거치지 않고 바로 `[...phone_book].sort()`를 해도 결과는 같습니다. (물론 중복 방어 코드로서는 훌륭합니다!)

2.  **가독성 개선 (find 활용)**:
    `for` 루프 대신 `some` 메서드를 쓰면 코드가 조금 더 "함수형"스럽고 간결해질 수 있습니다.
```typescript
function solution(phone_book: string[]) {
      const sorted = [...phone_book].sort();
      
      // 인접한 두 요소를 비교하여 하나라도 true면 즉시 종료
      const hasPrefix = sorted.some((phone, i) => {
        if (i === sorted.length - 1) return false;
        return sorted[i + 1].startsWith(phone);
      });

      return !hasPrefix;
    }
```


3.  **메모리 팁**:
    만약 메모리 사용량까지 타이트하게 관리해야 한다면, 원본을 복사(`[...]`)하지 않고 직접 `phone_book.sort()`를 사용하는 것이 유리합니다. (프로그래머스 환경에서는 원본 배열을 수정해도 채점에 영향을 주지 않거든요!) 하지만 실무에서는 질문자님이 하신 것처럼 복사본을 쓰는 습관이 훨씬 좋습니다. 👍

### 결론
`exam016-12077-a.ts` 방식이 정답입니다! **"문자열 접두어 찾기 = 사전순 정렬 후 인접 비교"**라는 공식을 아주 잘 찾아내셨어요. 😊

---
# Some은 뭐하는 함수?

`some()`은 배열의 요소들 중 **"조건을 만족하는 게 하나라도 있는지"** 확인하는 아주 유용한 함수예요!

### 1. 한 줄 요약
**"배열 안에 이 조건에 맞는 녀석이 하나라도 있어? (Yes or No)"**를 묻는 함수라고 생각하시면 됩니다. 결과값은 항상 `true` 또는 `false`로 나와요.

### 2. 특징
*   **중도 퇴근 (Short-circuiting):** 조건을 만족하는 요소를 찾는 즉시 실행을 멈추고 `true`를 반환합니다. (뒤에 남은 요소들은 쳐다보지도 않아요. 효율적이죠!)
*   **빈 배열:** 빈 배열에서 실행하면 무조건 `false`를 반환합니다.

### 3. 쉬운 예시
```javascript
const numbers = [1, 3, 5, 7, 8, 9];

// 배열에 짝수가 하나라도 있니?
const hasEven = numbers.some(num => num % 2 === 0);

console.log(hasEven); // true (8을 만나는 순간 "어! 있어!" 하고 끝남)
```


---

### 4. `every()`와 비교하면 더 쉬워요!
`some()`과 단짝인 `every()`도 있는데, 둘을 비교해보면 확실히 이해가 갑니다.

*   **`some()`**: "야, 이 중에 **하나라도** 합격이야?" (하나만 맞으면 OK)
*   **`every()`**: "야, 이거 **전부 다** 합격이야?" (전부 맞아야 OK)

```javascript
const scores = [90, 80, 40, 95];

const isOneFailed = scores.some(s => s < 60);  // true (과락이 하나라도 있는가?)
const isAllPassed = scores.every(s => s > 60); // false (모두 통과했는가?)
```


---

### 5. 아까 코드에서는 왜 썼나요?
작성하신 `for` 루프 코드와 비교해 보세요:

**기존 `for` 루프:**
```typescript
for (let i = 0; i < sortedPhoneBook.length - 1; i++) {
  if (sortedPhoneBook[i + 1].startsWith(sortedPhoneBook[i])) {
    return false; // 접두어를 찾으면 즉시 중단하고 false 반환
  }
}
return true; // 끝까지 못 찾으면 true
```


**`some()` 활용 버전:**
```typescript
const hasPrefix = sorted.some((phone, i) => {
  if (i === sorted.length - 1) return false;
  return sorted[i + 1].startsWith(phone); // 하나라도 startsWith가 true면 즉시 끝!
});

return !hasPrefix; // 찾았으면(true) 전체 결과는 false가 되어야 하므로 반전(!)
```


`some()`을 쓰면 루프를 직접 돌리고 중간에 `return`을 명시적으로 적어주는 번거로움이 줄어들어서 코드가 훨씬 간결해진답니다! 😊
