# lv1 삼총사 문제 해설

> 행렬의 덧셈을 구하는 문제였는데, 곱셈처럼 생각하고 있어서 해깔렸다. 
>
> **관련 문제**
>
> 내가 처음 풀은 코드
>
> * [exam028-131705.ts](../src/ts/lv_1/exam028-131705.ts)
>
> AI 제안 코드
>
> * [exam028-131705-a.ts](../src/ts/lv_1/exam028-131705-a.ts)



## 나

[exam028-131705.ts](../src/ts/lv_1/exam028-131705.ts) 이 코드는

배열을 받아서 배열의 3개 요소의 합이 0이 되는 경우의 수를 구하는 것이거든..

풀리긴하는데, 내가 좀 이상하게 풀은 것 같아 개선해 줄 수 있니?



## AI Assistant

안녕하세요! 코드를 검토해보니 몇 가지 개선할 수 있는 부분이 있네요.

현재 코드의 주요 문제점은:

1. 중복 계산이 많이 발생합니다
2. 마지막에 6으로 나누는 방식이 우아하지 않습니다
3. 불필요한 sum 변수의 더하고 빼는 연산이 많습니다

개선된 버전을 제안드립니다:

```ts
function solution(number: number[]): number {
  let count = 0;
  const n = number.length;
  
  // i, j, k를 순차적으로 증가시켜 중복 없이 조합을 확인
  for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
      for (let k = j + 1; k < n; k++) {
        if (number[i] + number[j] + number[k] === 0) {
          count++;
        }
      }
    }
  }
  
  return count;
}
```

주요 개선 사항을 설명드리면:

1. **중복 제거**: 
   - `i < j < k` 순으로 인덱스를 증가시켜서 같은 조합이 중복으로 계산되는 것을 방지했습니다
   - 이로 인해 마지막에 6으로 나눌 필요가 없어졌습니다
2. **성능 최적화**:
   - 불필요한 sum 변수의 누적/차감 연산을 제거했습니다
   - 각 반복문의 범위를 최적화했습니다 (`n-2`, `n-1`까지만 반복)
3. **코드 단순화**:
   - 불필요한 continue문을 제거했습니다
   - console.log 디버깅 코드를 제거했습니다
   - 더 명확하고 간결한 로직으로 개선했습니다
4. **타입 명시**:
   - 반환 타입을 명시적으로 지정했습니다 (`: number`)

이렇게 개선된 코드는 원래 코드와 동일한 결과를 출력하지만, 더 효율적이고 이해하기 쉬운 방식으로 작동합니다.

## 나

내가 본 코딩 테스트 사이트에서도 2번째 답안이 너와 같은 방법을 사용했더라구,

그런데, 나는 다음과 같은 부분이 생각이 잘 안떠오르는 것 같아.

1. j, k도 왠지 0부터 시작해야할 것 같은데...그게 아니구나.
2. i,j,k의 반복의 끝은..     i라면 j, k는 배제해야하니까 -2를 빼고,     j는 k를 배제해야해서 1을 뺀 것 겠지?

## AI Assistant

네, 정확히 이해하셨습니다! 이 부분을 좀 더 자세히 설명해드리겠습니다.

```ts
for (let i = 0; i < n - 2; i++) {      // 첫 번째 숫자 선택
    for (let j = i + 1; j < n - 1; j++) {  // 두 번째 숫자 선택
        for (let k = j + 1; k < n; k++) {  // 세 번째 숫자 선택
```

1. **왜 j와 k는 0부터 시작하지 않나요?**

   - 만약 모두 0부터 시작하면 같은 조합이 여러 번 중복으로 계산됩니다.

   - 예를 들어 배열 

     ```ts
     [1,2,3]
     ```

     이 있을 때:

     - i=0, j=1, k=2 로 (1,2,3) 조합을 찾았는데
     - i=1, j=0, k=2 로 다시 (2,1,3) 같은 조합을 찾게 됩니다

   - `j = i + 1`부터 시작하면 항상 `i < j < k` 순서가 보장되어 중복이 없어집니다

2. **반복문의 끝은 왜 그렇게 정했나요?**

```
   n = 배열 길이라고 할 때,
   i < n-2 인 이유: i 다음에 최소한 2개의 숫자(j,k)가 더 필요하기 때문
   j < n-1 인 이유: j 다음에 최소한 1개의 숫자(k)가 더 필요하기 때문
   k < n   인 이유: k는 마지막 숫자까지 모두 검사 가능
```

예시로 보면 더 이해가 쉬울 것 같네요:

```
// 배열이 [1,2,3,4,5] 라면 (n=5)
i는 0,1,2 까지만 (n-2=3)
  ㄴ i=0일 때 j는 1,2,3 까지만 (n-1=4)
       ㄴ j=1일 때 k는 2,3,4 까지
  ㄴ i=1일 때 j는 2,3 까지만
       ㄴ j=2일 때 k는 3,4 까지
...
```

이렇게 하면 모든 가능한 3개 숫자의 조합을 중복 없이 정확히 한 번씩만 검사할 수 있습니다!

## 나

먼저 한게 확실히 이상하긴 했어..😅

## AI Assistant

네, 첫 번째 시도하신 코드도 결과는 맞게 나왔지만 불필요한 계산이 많았죠! 😄

첫 번째 코드의 문제점을 조금 더 구체적으로 살펴보면:

1. **중복 계산의 문제**

```ts
   // 예: [-2, 3, 0] 이라는 조합을 검사할 때
   // (i,j,k) 순서로
   // (0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)
   // 이렇게 6번이나 같은 조합을 검사하게 됩니다
```

그래서 마지막에 `Math.trunc(answer / 6)`으로 보정이 필요했던 거죠.

1. **불필요한 sum 연산**

```ts
   sum += number[j];
   // ... 계산 후
   sum -= number[j];  // 다시 빼주기
```

이런 더하고 빼는 과정이 불필요하게 반복되었습니다.

개선된 버전은:

```ts
function solution(number: number[]): number {
  let count = 0;
  const n = number.length;
  
  for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
      for (let k = j + 1; k < n; k++) {
        if (number[i] + number[j] + number[k] === 0) {
          count++;
        }
      }
    }
  }
  
  return count;
}
```

이렇게 하면:

1. 각 조합을 딱 한 번만 검사
2. 단순한 덧셈으로 한 번에 확인
3. 더하고 빼는 중간 과정 없이 깔끔하게 처리

가 가능해집니다. 코딩 테스트에서는 이렇게 단순하고 명확한 해결 방법을 찾는 것이 중요합니다! 😊
