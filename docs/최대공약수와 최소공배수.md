# 최대공약수와 최소공배수

> 바로 안떠올라서 질문
>
> 그냥 했으면 1~ N까지 나눠서 나누어 떨어질 때까지 비교하려고 했다.
>
> **관련 문제**
>
> 두가지로 나눠보자... 일단은 그냥 내 처음생각대로 한 것... 😅
>
> * 유클리드 호제법 없이 바로 반복으로 돌격한 그냥한 내용...
>   * [exam024-12940.ts](../src/ts/lv_1/exam024-12940.ts)
>   * 제출을 해봤는데.. 점수는 +1점이긴 해도... 통과는 한다.. 😅
> * JetBrains AI가 추천한대로 유클리드 호제법 사용한 내용
>   * 



## 나

n과 m의 최소공배수가 n * m 이 아닐 때도 있니?

## AI Assistant

네, n과 m의 최소공배수(LCM)가 n * m이 아닐 때가 많습니다. 실제로 대부분의 경우에 최소공배수는 n * m보다 작습니다.

간단한 예를 들어보겠습니다:

1. n = 12, m = 18의 경우
   - n * m = 12 * 18 = 216
   - 실제 최소공배수 = 36 (216보다 훨씬 작음)
2. n = 6, m = 8의 경우
   - n * m = 6 * 8 = 48
   - 실제 최소공배수 = 24

이렇게 되는 이유는 두 수가 공약수를 가지고 있을 때입니다. 실제로 최소공배수(LCM)와 최대공약수(GCD)는 다음과 같은 관계를 가집니다:

```
LCM(n,m) * GCD(n,m) = n * m
```

따라서 두 수가 1보다 큰 공약수를 가지고 있다면(즉, GCD가 1보다 크다면), 최소공배수는 반드시 n * m보다 작게 됩니다.

예를 들어 설명드린 12와 18의 경우:

- 최대공약수(GCD)는 6입니다.
- 최소공배수(LCM)는 36입니다.
- 12 * 18 = 36 * 6 이 성립합니다.

이러한 관계 때문에 두 수의 곱(n * m)이 최소공배수가 되는 경우는 오직 두 수가 서로소(coprime)일 때, 즉 최대공약수가 1일 때뿐입니다.

## 나

그러면 일단 최대공약수를 먼저 구하고, (n*m) / GCD 를 하면 최소공배수를 구할 수 있겠네?

## AI Assistant

네, 정확히 맞습니다! 그것이 최소공배수를 구하는 가장 효율적인 방법 중 하나입니다.

수식으로 표현하면 다음과 같습니다:

```
LCM(n,m) = (n * m) / GCD(n,m)
```

실제 TypeScript 코드로 구현하면 이렇게 됩니다:

```ts
function gcd(a: number, b: number): number {
    // 유클리드 호제법을 사용한 최대공약수 계산
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

function lcm(n: number, m: number): number {
    // 최소공배수 계산: (n * m) / GCD(n,m)
    return Math.abs((n * m) / gcd(n, m));
}

// 사용 예시
console.log(lcm(12, 18));  // 출력: 36
console.log(lcm(6, 8));    // 출력: 24
```

여기서 주의할 점들이 있습니다:

1. **오버플로우 방지**: 큰 숫자의 경우 `n * m`이 먼저 계산될 때 숫자 범위를 초과할 수 있습니다. JavaScript/TypeScript에서는 `Number.MAX_SAFE_INTEGER`(2^53 - 1)를 넘지 않도록 주의해야 합니다.
2. **음수 처리**: 음수가 입력될 경우를 대비해 `Math.abs()`를 사용하여 결과의 절대값을 반환합니다.
3. **0 처리**: 입력값 중 하나가 0인 경우의 처리가 필요할 수 있습니다. (일반적으로 0과의 최소공배수는 0으로 정의됩니다)

더 안전한 버전의 코드는 이렇게 될 수 있습니다:

```ts
function safeLcm(n: number, m: number): number {
    // 0인 경우 처리
    if (n === 0 || m === 0) return 0;
    
    // 음수를 양수로 변환
    n = Math.abs(n);
    m = Math.abs(m);
    
    const gcdValue = gcd(n, m);
    // 오버플로우 방지를 위해 먼저 나누고 곱하기
    return (n / gcdValue) * m;
}
```

이 방식이 효율적인 이유는:

1. GCD를 구하는 유클리드 호제법의 시간 복잡도는 O(log(min(n,m)))으로 매우 효율적입니다.
2. 불필요하게 모든 공배수를 확인할 필요 없이 한 번의 계산으로 최소공배수를 구할 수 있습니다.
3. 큰 수에 대해서도 (오버플로우만 잘 처리한다면) 정확한 결과를 얻을 수 있습니다.

## 나

유클리드 호제법에 대해 설명해줄레?

## AI Assistant

유클리드 호제법(Euclidean Algorithm)은 두 수의 최대공약수(GCD)를 구하는 가장 효율적인 알고리즘입니다.

핵심 원리는 매우 간단합니다:

1. 두 양의 정수 a, b(a > b)에 대해서 a = bq + r (q는 몫, r은 나머지)라 하면
2. a와 b의 최대공약수는 b와 r의 최대공약수와 같다는 것입니다.

예를 들어 설명해드리겠습니다:

78과 52의 최대공약수를 구해봅시다:

```
78 = 52 × 1 + 26  (78을 52로 나누면 몫이 1, 나머지가 26)
52 = 26 × 2 + 0   (52를 26으로 나누면 몫이 2, 나머지가 0)
```

따라서 최대공약수는 26입니다.

TypeScript로 구현하는 방법은 크게 두 가지가 있습니다:

1. **재귀적 방법**:

```ts
function gcd(a: number, b: number): number {
    if (b === 0) return a;
    return gcd(b, a % b);
}

// 사용 예시
console.log(gcd(78, 52));  // 출력: 26
```

1. **반복문 방법**:

```ts
function gcd(a: number, b: number): number {
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// 사용 예시
console.log(gcd(78, 52));  // 출력: 26
```

작동 과정을 자세히 살펴보겠습니다:

78과 52의 최대공약수를 구하는 과정:

```
1단계: a = 78, b = 52
       78 = 52 × 1 + 26
       다음 단계로: a = 52, b = 26

2단계: a = 52, b = 26
       52 = 26 × 2 + 0
       다음 단계로: a = 26, b = 0

3단계: b가 0이므로 a(26)가 최대공약수
```

유클리드 호제법의 장점:

1. **효율성**: 시간 복잡도가 O(log(min(a,b)))로 매우 효율적입니다.
2. **단순성**: 구현이 매우 간단합니다.
3. **정확성**: 모든 경우에 대해 정확한 결과를 보장합니다.

주의할 점:

1. **음수 처리**: 실제 구현시에는 음수 입력에 대한 처리가 필요합니다.
2. **0 처리**: 한 수가 0인 경우의 처리가 필요합니다.
3. **소수점 처리**: 정수가 아닌 경우의 처리가 필요합니다.

더 안전한 버전의 구현은 이렇게 될 수 있습니다:

```ts
function safeGcd(a: number, b: number): number {
    // 정수가 아닌 경우 처리
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
        throw new Error('입력값은 정수여야 합니다.');
    }
    
    // 절대값으로 변환
    a = Math.abs(a);
    b = Math.abs(b);
    
    // 0인 경우 처리
    if (a === 0) return b;
    if (b === 0) return a;
    
    // 유클리드 호제법 적용
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    
    return a;
}

// 사용 예시
console.log(safeGcd(78, 52));     // 출력: 26
console.log(safeGcd(-78, 52));    // 출력: 26
console.log(safeGcd(0, 52));      // 출력: 52
```

이 알고리즘은 수학자 유클리드가 기원전 300년경에 제시한 것으로, 현재까지도 최대공약수를 구하는 가장 효율적인 방법으로 인정받고 있습니다.
