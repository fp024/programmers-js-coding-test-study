# 옹알이 (2) - 문제 해설

>  연속된 발음에서 약간 막혀서 질문했더니...
>  연속된 발음 문제 처리를 AI가 해결해줘버렸다. 😂
>  그런데 +3점 나와버렸다...😅 뭔가 애매하네...
>
>  **관련 문제**
>
>  [exam49-133499.ts](../src/ts/lv_1/exam049-133499.ts)



## 나

```ts
if (b.replace(/aya|ye|woo|ma/g, '').length === 0) {
  answer++;
}
```

이런 정규식이 있다면 yeye 문자열을 검사할 경우 통과가 되지 않니?

## AI Assistant

네, 맞습니다. `yeye`와 같이 연속으로 같은 발음이 나오는 경우에도 이 정규식은 해당 문자열을 통과시키는 문제가 있습니다.

현재 정규식 `/aya|ye|woo|ma/g`는 단순히 해당 패턴들을 찾아서 제거하기만 하고, 같은 발음이 연속으로 나오는 경우를 체크하지 않습니다.

문제의 요구사항을 정확히 구현하려면, 연속된 같은 발음을 체크하는 로직이 추가로 필요합니다. 다음과 같이 수정할 수 있습니다:

```ts
for (let b of babbling) {
  // 연속된 같은 발음이 있는지 체크
  if (/(aya|ye|woo|ma)\1+/.test(b)) {
    continue; // 연속된 발음이 있으면 건너뜀
  }
  
  // 기존 발음 체크
  if (b.replace(/aya|ye|woo|ma/g, '').length === 0) {
    answer++;
  }
}
```

위 코드에서:

- ```
  /(aya|ye|woo|ma)\1+/
  ```

   : 이 정규식은 같은 발음이 1회 이상 연속되는 패턴을 찾습니다.

  - `\1+`는 앞에서 매치된 그룹이 1번 이상 반복되는 것을 의미합니다.

- 연속된 발음이 발견되면 그 문자열은 건너뛰고 다음으로 넘어갑니다.

이렇게 하면 `yeye`와 같은 연속된 발음을 포함하는 문자열은 올바르게 처리됩니다.

## 나

너 이 문제에 대해서 잘 알고 있었니?

## AI Assistant

네, 이 문제는 프로그래머스의 "옹알이 (2)" 문제입니다. 파일의 주석에서 문제 URL도 확인할 수 있네요.

주요 요구사항은:

1. 아기가 발음할 수 있는 단어는 "aya", "ye", "woo", "ma" 네 가지입니다.
2. 같은 발음을 연속해서 하면 안 됩니다. (예: "yeye"는 불가능)
3. 발음할 수 있는 단어들을 조합해서 만들 수 있는 발음만 가능합니다.

제가 앞서 답변한 내용은 문제의 중요한 제한사항인 "연속된 같은 발음은 불가능하다"는 부분을 구현하는 방법을 설명드린 것입니다.

이 문제의 함정 중 하나가 바로 "yeye"와 같은 연속된 발음을 처리하는 부분인데요. 단순히 발음 가능한 문자열을 체크하는 것만으로는 부족하고, 연속된 같은 발음을 걸러내는 로직이 반드시 필요합니다.

## 나

제출하니까 +3점 나오더라..😅  다른사람 풀이하고 중복도 안되었어...

## AI Assistant

아하! 축하드립니다! 😊

정규식을 활용한 이런 풀이 방식이 다른 사람들의 풀이와 차별화되어서 +3점을 받으신 것 같네요. 정규식의 캡처 그룹과 역참조(`\1`)를 활용한 방식은 꽤 우아한 해결책이라고 할 수 있습니다.

일반적으로 많은 사람들은 이런 문제를:

1. 문자열을 순회하면서 일일이 체크하거나
2. 각 발음을 배열로 관리하고 indexOf나 includes로 확인하거나
3. 중첩 반복문을 사용해서 해결하는 경우가 많은데

정규식을 활용하면 코드도 간결해지고, 성능도 나쁘지 않습니다. 특히 문자열 패턴 매칭에서는 정규식이 매우 강력한 도구죠.

앞으로도 이런 문자열 처리 문제를 만나면 정규식 활용을 고려해보시면 좋을 것 같습니다. 좋은 점수 받으신 것 정말 축하드려요! 👏

## 나

`/(aya|ye|woo|ma)\1+/` 이 수식이  겉보기에는 마치...

1개 이상이라고 표현된 것 같아서 하나만 있어도 통과할 것 같은 느낌이 드는건 뭘까?

## AI Assistant

아, 좋은 지적이십니다! 이 정규식의 표현 방식에 대해 자세히 설명드리겠습니다.

`/(aya|ye|woo|ma)\1+/`에서:

1. `(aya|ye|woo|ma)` - 첫 번째 그룹을 캡처합니다 (예: "ye")
2. `\1` - 첫 번째 캡처 그룹과 **정확히 동일한** 문자열을 참조합니다
3. `+` - 앞의 패턴(`\1`)이 1회 이상 반복됨을 의미합니다

따라서:

- `ye` 하나만 있는 경우: 매치되지 않습니다 (두 번째로 반복되는 `\1`이 없기 때문)
- `yeye`의 경우: 매치됩니다 (`ye`가 캡처된 후 동일한 `ye`가 바로 뒤에 나옴)

좀 더 명확하게 이해하기 위한 예시를 들어보면:

```ts
let regex = /(aya|ye|woo|ma)\1+/;

console.log(regex.test("ye"));      // false - 하나만 있어서 매치 안됨
console.log(regex.test("yeye"));    // true  - ye가 연속으로 있어서 매치됨
console.log(regex.test("yeyeye"));  // true  - ye가 연속으로 여러번 있어서 매치됨
console.log(regex.test("yeayaye")); // false - ye와 aya가 번갈아 나와서 매치 안됨
```

즉, `+`는 `\1`(첫 번째 그룹의 반복)에 적용되는 것이지, 전체 패턴에 적용되는 것이 아닙니다. 그래서 반드시 같은 패턴이 연속으로 나와야 매치가 됩니다.