# 주식 가격 - 42584 문제 해설

> 문제 URL
>
> * https://school.programmers.co.kr/learn/courses/30/lessons/12924
>
> 내가 처음 풀은 코드 O(n^2)
>
> * [exam013-42584.ts](../../src/ts/lv_2/exam013-42584.ts)
>
> 스택 사용 코드 O(n)
>
> * [exam013-42584-a.ts](../../src/ts/lv_2/exam013-42584-a.ts)
>
>   





## AI 가이드

## 스택 활용 아이디어

**1. 스택에는 "인덱스"를 저장합니다**

- 가격 값이 아니라 **배열의 인덱스(i)**를 넣어요

**2. 스택의 역할: "아직 가격이 안 떨어진 시점들을 기억"**
- 스택에 들어있는 인덱스들 = 아직 가격이 떨어지지 않은 시점들

**3. 핵심 로직:**
- 현재 가격이 **스택 맨 위 인덱스의 가격보다 낮으면**
- 스택에서 pop하면서 그 시점의 정답을 계산
- 현재 시점에서 pop된 시점을 빼면 = 버틴 시간!

**4. 반복:**
- 현재 가격보다 높은 가격들을 스택에서 모두 제거
- 그 다음 현재 인덱스를 스택에 push

**5. 마지막 처리:**
- 반복문이 끝나고 스택에 남은 인덱스들은?
- 끝까지 가격이 안 떨어진 애들이니까 (배열 길이 - 인덱스 - 1)로 계산

이렇게 하면 O(N) 시간복잡도로 해결할 수 있어요!


이런 **스택 문제**는 실제로 **그림(혹은 표)**을 그려보면 동작 원리가 훨씬 잘 이해됩니다.



### 그림 그리는 팁

1. **prices 배열을 한 줄로 적고, 각 인덱스별로 스택의 변화**를 옆에 적어보세요.
2. 각 시점마다  
   - 스택에 push되는 인덱스  
   - pop되는 인덱스와 그때 계산되는 값  
   - 마지막에 남은 인덱스 처리  
   를 순서대로 써보면,  
   **"각 인덱스가 push/pop이 딱 한 번씩만 일어나는구나!"**  
   를 직접 확인할 수 있습니다.

### 예시 (간단하게)

| i    | prices[i] | stack(변화)                        | answer(변화)                                                 |
| ---- | --------- | ---------------------------------- | ------------------------------------------------------------ |
| 0    | 1         | [0]                                | [0, 0, 0, 0, 0]                                              |
| 1    | 2         | [0,1]                              | [0, 0, 0, 0, 0]                                              |
| 2    | 3         | [0,1,2]                            | [0, 0, 0, 0, 0]                                              |
| 3    | 2         | pop 2→1, [0,1,3]                   | answer[2]=1<br />[0, 0, 1, 0, 0, 0]                          |
| 4    | 3         | [0,1,3,4]                          | [0, 0, 1, 0, 0, 0]                                           |
| 끝   |           | pop 4→0, pop 3→1, pop 1→3, pop 0→4 | answer[4]=0, answer[3]=1, answer[1]=3, answer[0]=4<br />[4, 3, 1, 1, 0, 0] |

이런 식으로 표를 그려보면  
**스택이 어떻게 동작하는지, 왜 O(N)인지** 확실히 감이 옵니다!

**정리:**  
- 헷갈릴 땐 꼭 그림/표로 시각화!  
- 손으로 써보면 금방 이해돼요 😊



## 나:

근데 이게 왜 O(N)으로 치는거야... 겉으로 봤을 때는 for, while로 2중 반복이 있긴하잖아.



## AI:

좋은 질문이에요! 겉보기에는 for + while로 중첩 반복문처럼 보이지만, **실제로는 O(N)**입니다.

## 핵심 포인트: "각 원소는 최대 2번만 처리"

**분석해보면:**
1. **각 인덱스는 스택에 정확히 1번만 push됩니다** (for문에서)
2. **각 인덱스는 스택에서 최대 1번만 pop됩니다** (while문에서)

즉, 전체 N개 원소에 대해:
- push 연산: N번
- pop 연산: 최대 N번
- **총 연산 횟수: 최대 2N번**

## 예시로 확인:
`[5, 4, 3, 2, 1]`에서
- i=0: push(0) → 1번 연산
- i=1: pop(0) + push(1) → 2번 연산  
- i=2: pop(1) + push(2) → 2번 연산
- i=3: pop(2) + push(3) → 2번 연산
- i=4: pop(3) + push(4) → 2번 연산

**총 9번 연산** (2N-1번)

## 왜 O(N²)가 아닌가?
while문이 중첩되어 있지만, **각 원소는 한 번 들어가서 한 번만 나오기** 때문에  
전체적으로는 선형 시간이 됩니다.

이런 패턴을 **"amortized O(N)"** 또는 **"분할상환 분석"**이라고 해요!