

# 소수 찾기 - 에라토스테네스의 체

> 소수 찾기를 일단 풀어봤는데, 효율성 테스트에서 실패해서, AI에게 질문을 해보았다. 😂
>
> **관련 문제**
>
> 내가 처음 풀은 코드 (효율성 테스트 1, 2, 4 실패)
>
> * [exam047-12921.ts](../src/ts/lv_1/exam047-12921.ts)
>
> 나누는 수를 먼저 구한 소수들로 사용하도록 최적화 시도 (효율성 테스트 성공)
>
> * [exam047-12921-a.ts](../src/ts/lv_1/exam047-12921-a.ts)





## 나

안녕....

"에라토스테네스의 체"에 대해서 설명을 해주라 😅

## AI Assistant

안녕하세요! 에라토스테네스의 체에 대해 설명해 드리겠습니다.

에라토스테네스의 체(Sieve of Eratosthenes)는 특정 범위 안에 있는 모든 소수를 찾는 효율적인 알고리즘입니다.

작동 방식은 다음과 같습니다:

1. 2부터 n까지의 모든 수를 나열합니다.
2. 가장 작은 수인 2를 소수로 표시하고, 2의 배수를 모두 지웁니다.
3. 남아있는 수 중 가장 작은 수(3)를 소수로 표시하고, 그 배수를 모두 지웁니다.
4. 이 과정을 √n까지 반복합니다.

간단한 예시로 설명하면:

```typescript
function sieveOfEratosthenes(n: number): number[] {
    // 2부터 n까지의 숫자를 모두 true로 초기화
    const isPrime = new Array(n + 1).fill(true);
    isPrime[0] = isPrime[1] = false;

    // 에라토스테네스의 체 실행
    for (let i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            // i의 배수들을 모두 false로 표시
            for (let j = i * i; j <= n; j += i) {
                isPrime[j] = false;
            }
        }
    }

    // 소수만 배열에 담아서 반환
    return isPrime.reduce((primes, isPrime, num) => {
        if (isPrime) primes.push(num);
        return primes;
    }, [] as number[]);
}
```

이 알고리즘의 장점:

1. 구현이 비교적 간단합니다.
2. 여러 개의 소수를 한 번에 찾을 때 매우 효율적입니다.
3. 시간 복잡도는 O(n log log n)으로, 단순히 모든 수를 나누어보는 방식보다 훨씬 빠릅니다.

현재 보이는 코드에서는 divisorCount 함수를 사용하여 각 숫자마다 소수인지 확인하고 있는데, 많은 수의 소수를 찾아야 하는 경우에는 에라토스테네스의 체를 사용하는 것이 더 효율적일 수 있습니다.

특히 프로그래머스의 소수 찾기 문제와 같이 큰 범위의 숫자에서 소수의 개수를 구해야 하는 경우, 에라토스테네스의 체를 사용하면 실행 시간을 크게 단축할 수 있습니다.
