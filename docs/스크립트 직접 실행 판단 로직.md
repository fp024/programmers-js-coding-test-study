# 스크립트 직접 실행 판단 로직 `isDirectRun()`

````javascript
export function isDirectRun(moduleUrl) {
  const invoked = process.argv[1] ? path.resolve(process.argv[1]) : "";
  const modulePath = fileURLToPath(moduleUrl);
  return invoked === modulePath;
}
````

---

## 1. 함수 목적

- **ESM(ECMAScript Module) 환경에서 현재 모듈이 node로 직접 실행된 것인지(즉, `node 파일명.js`로 실행된 것인지) 판단**  
- 라이브러리처럼 import된 경우에는 false, 직접 실행된 경우에만 true를 반환

---

## 2. 각 줄 설명

#### `const invoked = process.argv[1] ? path.resolve(process.argv[1]) : "";`
- `process.argv[1]`: Node.js에서 **현재 실행된 스크립트의 경로**
  - 예: `node src/foo.js`로 실행하면 `src/foo.js`
- `path.resolve()`: 이 경로를 **절대경로**로 변환
- `process.argv[1]`이 없으면 빈 문자열 사용

#### `const modulePath = fileURLToPath(moduleUrl);`
- `moduleUrl`: 보통 `import.meta.url`로 전달
- `import.meta.url`: `file:///C:/.../foo.js` 같은 **파일 URL**
- `fileURLToPath()`: 파일 URL을 **로컬 파일 시스템의 절대경로**로 변환

#### `return invoked === modulePath;`
- **실행된 스크립트의 절대경로**와 **현재 모듈의 절대경로**를 비교
- 같으면 true(직접 실행), 다르면 false(import)

---

## 3. 예시

### 직접 실행

```sh
node src/a.js
```
- `process.argv[1]` → `src/a.js`
- `path.resolve(process.argv[1])` → `c:\test-project\src\a.js`
- `import.meta.url` → `file:///c:/test-project/src/a.js`
- `fileURLToPath(import.meta.url)` → `c:\test-project\src\a.js`
- 두 경로가 같으므로 **true 반환**

### import로 사용 (예: 테스트 코드)

```javascript
import { addCompilerOption } from "./a.js";
```
- `process.argv[1]` → 예: `c:\Users\user\AppData\Local\pnpm\vitest.CMD`
- `path.resolve(process.argv[1])` → `c:\Users\user\AppData\Local\pnpm\vitest.CMD`
- `fileURLToPath(import.meta.url)` → `c:\test-project\src\a.js`
- 경로가 다르므로 **false 반환**

---

## 4. 요약

- **직접 실행**: `node 파일명.js` → true
- **import 사용**: 다른 파일에서 import → false

이렇게 하면 스크립트를 라이브러리로도, CLI로도 안전하게 사용할 수 있다.

